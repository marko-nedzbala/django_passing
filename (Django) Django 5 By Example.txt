
https://github.com/PacktPublishing/Django-5-by-Example

Apps
Blog:                       Chapters 1 to 3 -> 1, 2, 3
Image bookmarking website:  Chapters 4 to 7 -> 4, 5, 6, 7
Online Shop:                Chapters 8 to 11 -> 8, 9, 10, 11
e-Learning Platform:        Chapters 12 to 17 -> 12, 13, 14, 15, 16, 17



Chapter01
Building a Blog Application

telling Django to run on a custom port and use a specific settings.py file
$ python manage.py runserver 127.0.0.1:8001 --settings=mysite.settings

In Django 5, can define default values for model fields using database-computed default values
from django.db.models.functions import Now

to get the user settings
from django.conf import settings

the migrate command applies migrations for all applications listed in INSTALLED_APPS

displaying your model in the admin.py

from django.contrib import admin
from .models import Post
@admin.register(Post)
class PostAdmin(admin.ModelAdmin):
    list_display = ['title', 'slug', 'author', 'publish', 'status']
    list_filter = ['status', 'created', 'publish', 'author']
    search_fields = ['title', 'body']
    prepopulated_fields = {'slug': ('title',)}
    raw_id_fields = ['author']
    date_hierarchy = 'publish'
    ordering = ['status', 'publish']

Creating objects
my_model_instance = MyModel(attribute=value)
my_model_instance.save()

OR

my_model_instance = MyModel.objects.create(attribute=value)

Define an enumeration within your model

class MyModel(models.Model):
    class MyEnum(models.TextChoices):
        CONDITION01 = 'CD01', 'Cond_01' # value, human-readable name
        CONDITION02 = 'CD02', 'Cond_02'

    title = models.CharField(max_length=250)
    my_condition = models.CharField(max_length=4, choices=MyEnum, default=MyEnum.CONDITION01)

# now examples of calling them via $ python manage.py shell
from my_app.models import MyModel
MyModel.MyEnum.choices  # obtain the enum choices
MyModel.MyEnum.labels   # human-readable names of enum members, the Cond_01
MyModel.MyEnum.values   # values stored in the database, the CD01
MyModel.MyEnum.names    # names, the CONDITION01

Referencing a user
from django.conf import settings
class MyModel(models.Model):
    # related name allows us easy access
    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='blog_posts'),

Field lookups
MyModel.objects.filter(title__contains='A Name')
field__lookup

Q objects allow for complex lookups
from django.db.models import Q
starts_who = Q(title__istartswith='who')
starts_why = Q(title__istartswith='why')
Post.objects.filter(starts_who | starts_why)

Model manager
default model manager is objects

2 ways to customize managers
1.) Add extra manager methods to an existing manager
QuerySet notation MyModel.objects.my_manager()

2.) Create a new manager by modifying the initial QuerySet that the manager returns
MyModel.my_manager.all()

# example
class PublishedManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(status=Post.Status.PUBLISHED)

class MyModel:....
    objects = models.Manager()  # the default manager
    published = PublishedManager()  # Our custom manager


default manager: first manager declared in the model
Meta attribute to use default_manager_name to specify a default manager

Views
# example of 404 not found
from django.shortcuts import render, get_object_or_404
def post_detail(request, id):
    post = get_object_or_404(Post, id=id, status=Post.Status.PUBLISHED)
    return render(request, 'blog/post/detail.html', {'post': post})

referencing the app_name in the main urls.py file
from django.urls import include, path

urlpatterns = [
    path('blog/', include('blog.urls', namespace='blog')),
]

# to access the namespace later
my_namespace:name_given_to_url
blog:post_list

Templates
quick overview of templates
template tags: {% tag %} control the rendering of your template
template variables: {{ variable }} get replaced with values when the template is rendered
template filters: {{ variable|filter }} allow you to modify variables for display

URL patterns map URLs to views, and views decide which data gets returned to the user

Additional resources page 85



Chapter02
Enhancing Your Blog and Adding Social Features

Setps through a cookbook approach to create different pages

Canonical URLs for models
canonical URLs allow you to specify the URL for the master copy of a page, use get_absolute_url()

create the canoncial URL
reverse() will build the URL from the parameters we pass in

from django.urls import reverse
class MyModel...
    def get_absolute_url(self):
        return reverse('blog:post_detail', args=[self.id])

# now we can refer globally refer to this string
<a href="{% url 'blog:post_detail' post.id %}">
becomes
<a href="{{ post.get_absolute_url }}">

Pagination
my_views.py

from django.core.paginator import EmptyPage, Paginator, PageNotAnInteger

def my_view(request):
    paginator = Paginator(my_list, 3)
    page_number = request.GET.get('page', 1)
    // to handle empty pages
    try:
        posts = paginator.page(page_number)
    except PageNotAnInteger:
        posts = paginator.page(1)
    except EmptyPage:
        posts = paginator.page(paginator.num_pages)

HTML example of our pagination
<div class="pagination">
    <span class="step-links">
        {% if page.has_previous %}
            <a href="?page={{ page.previous_page_number }}">Previous</a>
        {% endif %}
        <span class="current">
            Page {{ page.number }} of {{ page.paginator.num_pages }}
        </span>
        {% if page.has_next %}
            <a href="?page={{ page.next_page_number }}">Next</a>
        {% endif %}
    </span>
</div>

Class-based views

class PostListView(ListView):
    queryset = Post.published.all()
    context_object_name = 'posts'
    paginate_by = 3
    template_name = 'blog/post/list.html'

pagination requires
{% include "pagination.html" with page=page_obj %}



Creating forms with Django
uses the forms framework to create forms quickly
1.) Form: build standard forms by defining fields and validations
2.) ModelForm: build forms tied to model instances

Form requires a form.py file

Sending emails

following settings allow you to define the SMTP configuration to send emails with Django:
    EMAIL_HOST: The SMTP server host; the default is localhost
    EMAIL_PORT: The SMTP port; the default is 25
    EMAIL_HOST_USER: The username for the SMTP server
    EMAIL_HOST_PASSWORD: The password for the SMTP server
    EMAIL_USE_TLS: Whether to use a Transport Layer Security (TLS) secure connection
    EMAIL_USE_SSL: Whether to use an implicit TLS secure connection

Working with environment variables
uses the python-decouple library
$ python -m pip install python-decouple
name the file .env, and place in the root directory

might need to install a certify module
$ pip install --upgrade certifi

actually needed this library
$ pip install pip-system-certs

Professional email service
SendGrid
Amazon Simple Email Service (SES)

can use the django-anymail package

Django backend
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

Creating an App password in Gmail
https://myaccount.google.com/apppasswords

from django.core.mail import send_mail
send_mail('Django mail', 'This email was sent with Django', 'marko.nedzbala@gmail.com', ['marko.nedzbala.gmail.com'], fail_silently=False)

passing around URLs and data

in detail.html
{% url 'app_name:view_name' model_name.id %}

in views.py
def view_name(request, my_id):
    return render (request, 'app_name/model_name/share.html', {'model_object': model_name })

the {% with %} template tag is useful for avoiding hitting the database or accessing  expensive methods multiple times.

Creating a comment system
{% with %} useful to avoiding hitting the database or accessing expensive methods multiple times
allows an assignment to a new variable that will be available in the template
# example
{% with comments.count as total_comments %}
    <h2>{{ total_comments }} comment{{ total_comments|pluralize }}</h2>
{% endwith %}

Simplified templates for form rendering
field groups: simplify the rendering of labels, widgets, help texts and field errors
field group templates:



Chapter03
Extending Your Blog Application

catergorizing posts using tags
use django-taggit
$ pip install django-taggit

Creating custom template tags and filters
https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/.
Django provides helper functions to create template tags
1.) simple_tag: processes the given data and returns a string
2.) inclusion_tag: processes the given data and returns a rendered template

@register.simple_tag

Custom template filters
https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/#writing-custom-template-filters.

Adding a sitemap to the site
an XML file that tells search engines the pages of your website, their relevance and how frequently they are updated
depends on:
django.contrib.sites
django.contrib.sitemaps

sitemaps.py

to access your sitemap
http://localhost:8000/sitemap.xml

https://docs.djangoproject.com/en/5.0/ref/contrib/sites/

Change the domain to be used with your sitemap
http://localhost:8000/admin/sites/site/

Creating feeds
feeds.py

to view your feed in Chrome
http://localhost:8000/blog/feed/

For full text-search will use PostgreSQL

One thing of note, the directions were incorrect for such a new book

use Docker
$ docker pull postgres:16.2
$ docker run --name=blog_db -e POSRGRES_DB=blog -e POSTGRES_USER=blog -e POSTGRES_PASSWORD=blog -p 6000:5432 -h 127.0.0.1 -d postgres:16.2

install psycopg PostgreSQL adapter for Python
$ pip install psycopg2-binary
$ pip install psycopg==3.1.18

need to dump data
// this errored
$ python manage.py dumpdata --indent=2 --output=mysite_data.json

$ python manage.py dumpdata --natural-foreign --natural-primary -e contenttypes -e auth.Permission --indent 2 > dump.json

edit the .env file
DB_NAME=blog_db
DB_USER=blog
DB_PASSWORD=blog
DB_HOST=localhost

configure the database settings in settings.py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': config('DB_NAME'),
        'USER': config('DB_USER'),
        'PASSWORD': config('DB_PASSWORD'),
        'HOST': config('DB_HOST'),
    }
}

make sure you run $ python manage.py runserver

now load the previosuly dumped data
$ python manage.py loaddate mysite_data.json

the dumping and loading seemed to cause a problem
need to change the 'pk' of contenttypes.contenttype to 'id'
https://stackoverflow.com/questions/40193992/django-loaddata-unique-constraint-failed

to use PostgresSQL full search abilities
django.contrib.postgres



Chapter04
Building a Social Website

django.contrib.auth application and 2 middleware classes
1.) AuthenticationMiddleware: associates users with requests using sessions
2.) SessionMiddleware: handles the current session across requests

Authentication framework also includes the following models that are defined in django.contrib.auth.models
1.) User: a user model with basic fields, the main fields are:
    username
    password
    email
    first_name
    last_name
    is_active
2.) Group: a group model to categorize users
3.) Permission: flags for users or groups to perform certain actions






























LEFT OFF PAGE 198

Apps
Blog: CHs 1 to 3 -> 1,2,3 [DONE]
Image bookmarking website: CHs 4 to 7 -> 4,5,6,7
Online Shop: CHs 8 to 11 -> 8,9,10,11
e-Learning Platform: CHs 12 to 17 -> 12,13,14,15,16,17

Where a chapter begins
CH04    198
CH05    244
CH06    270
CH07    318
CH08    372
CH09    430
CH10    488
CH11    526
CH12    570
CH13    600
CH14    640
CH15    678
CH16    712
CH17    754
END     802




















































 
